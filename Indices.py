import datetime

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt

from datetime import datetime

end = datetime.now().strftime('%Y-%m-%d')
etf_data = {}

tickers = ['SPY', 'QQQ', 'IWM', 'DIA', 'VOO', 'EEM', 'EFA', 'MDY', 'IJH', 'IJR',
        'XLE', 'XLF', 'XLK', 'XLV', 'XLY', 'XLP', 'XLI', 'XLU', 'XLB', 'XLRE',
        'VWO', 'FXI', 'EWY', 'EWJ', 'EWZ', 'EWW', 'EWG', 'INDA', 'FEZ', 'EWH',
        'TLT', 'LQD', 'HYG', 'JNK', 'GOVT', 'BND', 'TIP', 'IEF', 'SHY', 'SJNK',
        'GLD', 'SLV', 'USO', 'DBC', 'PLL', 'PPLT', 'CORN', 'WEAT', 'DBA', 'UCO',
        'VIXY', 'VXX', 'UVXY', 'SVXY', 'USMV', 'ACWV', 'TAIL', 'SPLV', 'JEPI', 'WTMF',
        'TQQQ', 'SQQQ', 'UPRO', 'SSO', 'SPXL', 'SPXS', 'URTY', 'TNA', 'TZA',
        'VIG', 'DVY', 'SCHD', 'SDY', 'HDV', 'VYM', 'NOBL', 'DGRW', 'PGX', 'SDIV',
        'ARKK', 'ARKW', 'ARKG', 'BOTZ', 'ICLN', 'SKYY', 'LIT', 'SOXX', 'SMH', 'CNRG',
        'BITO', 'XBTF', 'BTF', 'BLOK', 'BKCH',
        'ESGU', 'EFIV', 'ESGV', 'NULV', 'DMXF']

for idx, ticker in enumerate(tickers, start=1):
    etf_data[idx] = {
        "ticker" : ticker,
        "data" : yf.Ticker(ticker).history(start='2012-01-01', end=end, actions=True, auto_adjust=True) 
        #Actions is whether to include dividens and splits, it's True by default.
        #For easier manipulation, in case some ETFs have and adjusted close, the auto_adjust makes the Close being automatically adjusted.
    }
    print(f"Fetching data for {ticker} (ID: {idx})...")

#Structure of the "finished" dictionary:
#etf_data = {
#   1 : {
#       ticker : 'SPY',
#       data :  Dataframe
#   },
#   2 : ...
#}

vol_window = 7 #Number of periods for vol calculations.
mom_window = 7 #Number of periods for momentum calculations.
for_window = 7 #Number of periods for the forecasting
mom_1 = 1 #First momentum thresold, in percentages of move.
x = 0

for index, etf_info in etf_data.items():
    data = etf_info['data'] #Here we extract the dataframe from the dictionary
    data['Log_returns'] = np.log(data['Close'] / data['Close'].shift(1))
    data['Volatility'] = data['Log_returns'].rolling(window=vol_window).std()
    Vol_20th = data['Volatility'].quantile(0.2) 
    data['Signal_vol'] = data['Volatility'] <= Vol_20th
    data['Momentum'] = ((data['Close'] - data['Close'].shift(mom_window)) / data['Close'].shift(mom_window)) *100
    data['Signal_mom_1'] = data['Momentum'].abs() <= mom_1

    data = data.dropna() #Dropping the NaN generated by shifting
    data = data.drop(columns=['Volume', 'Dividends', 'Stock Splits'])

    etf_info['data'] = data #Updating the dictionary

    ###
    # Up till now, what it's done is the creation of the "analysis" columns.
    # With these columns we have our criteria, vol lower than 20% historical vol and momentum less or equal than certain percentage.
    # Now, it's turn to do the "forecasting", I will take the days that fit the criteria, and see the forecast move for a certain period.
    # How will I determine the forecast is good or bad?
    # First we have to know that I'm taking the historical volatility, including periods not yet happened in the data. 
    # For a forecast of 2019, the volatility thresold includes vol from 2020, 2021...
    # So, with that in mind, I will look up the premium of an ATM straddle, get the percentages in which it would've made money in this circunstances,
    # and then apply that to the good/bad forecasting.

    data['Future_Close'] = data['Close'].shift(-for_window)
    data['Forecast_Move'] = ((data['Future_Close'] - data['Close']) / data['Close']) * 100
    data['Forecast_Move_abs'] = data['Forecast_Move'].abs()

    # Signal_1: Both Signal_vol and Signal_mom_1 must be True (1)
    data['Signal_1'] = ((data['Signal_vol']) & (data['Signal_mom_1'])).astype(int)

    etf_info['data'] = data
    print(f'Etf number {index} done.')

    if x == 0:
        print(data['Momentum'].head())
        print(data[data['Signal_1'] == 1].tail(25))
        x += 1

x = x+2

results = []

for index, etf_info in etf_data.items():
    name = etf_info['ticker']
    data = etf_info['data']
    filtered_data = data[data['Signal_1'] == 1]

    if filtered_data.empty:
        print(f'Etf number {index}, has no rows that match criteria. Investigatee further\n'
              f'ETF = {name}')
        continue

    mean = filtered_data['Forecast_Move_abs'].mean()
    median = filtered_data['Forecast_Move_abs'].median()
    std = filtered_data['Forecast_Move_abs'].std()

    results.append({
        #"ETF_ID": index,                     # Unique identifier for the ETF
        "ETF_Name": name,              # ETF ticker name
        "Mean_Forecast_Move": mean,  # Mean of Forecast_Move_asb
        "Median_Forecast_Move": median,  # Median of Forecast_Move_asb
        "Std_Forecast_Move": std     # Standard deviation of Forecast_Move_asb
    })

sumary_table = pd.DataFrame(results)

pd.set_option('display.max_rows', None)  # Show all rows
pd.set_option('display.max_columns', None)  # Show all columns

print(sumary_table)
